**Introduction:**
-------------------

As we move on to our second project, "Rock, Paper, Scissors," you'll see that the fundamental concepts of programming continue to be at the heart of the game. It's a step forward from our first project, "Guess My Number," but everything you've learned and practiced so far will be directly applicable and crucial to completing this project.

Variables: In "Rock, Paper, Scissors," variables hold key pieces of data such as the player's choice and the computer's choice. These variables interact with one another to determine the outcome of the game.

Conditionals: The game's outcome depends entirely on a set of conditions: rock crushes scissors, scissors cut paper, and paper covers rock. Implementing these rules in the game requires the use of conditional statements to compare the choices and decide the winner.

Arrays: Arrays can be used to store the game options (rock, paper, and scissors). The computer's choice can then be selected randomly from this array, showcasing a different application of arrays compared to the first project.

Loops: The game can be played repeatedly, allowing for multiple rounds. This is facilitated by loops, which will enable the game to continue until the player decides to stop.

Functions: Functions in this game can handle various tasks such as taking the player's input, generating the computer's choice, comparing the choices, declaring the winner, and more. This compartmentalization of tasks within functions leads to cleaner, more organized code.

Even though "Rock, Paper, Scissors" is a simple game, it offers excellent opportunities to practice and understand how these fundamental programming concepts interact in a real application. Moreover, it builds directly on what you've learned and applied in the "Guess My Number" game, reinforcing those skills and introducing a few new challenges.

As you progress through this project, we can't stress enough the importance of writing good, clean code. Even for a simple game like this, well-structured, readable, and maintainable code can significantly enhance its functionality and your understanding of it. It allows for easy debugging and future improvements, and it sets a high standard for any code you write in the future.

In conclusion, "Rock, Paper, Scissors" is more than just a game—it's a practical, hands-on lesson in the fundamental concepts of programming and a stepping stone towards more complex projects. Let's continue our programming journey with this fun and engaging project!

**Project Requirements**:  
-------------------

Before you write any code, you should "sketch" the pseudo code and make a flowchart for how you plan to do the following alterations to the game.

Module Requirements:

1. **Implement a Start Screen**
   - Create a basic start screen with an option to start the game. The game should not start until the user chooses to do so.

2. **Implement a Game Replay Option**
   - After a game concludes, navigate back to the start screen. The user should have the option to play again or exit the game. Test the functionality to ensure it works as expected.

3. **Extend the Game to "Rock Paper Scissors Spock Lizard"**
   - Begin by coding the logic for a "Rock Paper Scissors" game. After ensuring that this base game functions correctly, extend it to "Rock Paper Scissors Spock", and finally to "Rock Paper Scissors Spock Lizard".
   - Use debugging tools to identify and correct any errors in your game logic.

4. **Support Multiple Languages**
   - Modify your game to support an additional language. Once you have successfully implemented dual-language support, expand your game to support multiple languages.
   - Use debugging tools to identify and correct any errors that arise in the language implementation.

5. **Refactor Your Code**
   - After implementing all the above features, review your code for potential improvements. Your goal is to make your code more efficient, readable, and maintainable. It is a god idea to document your refactoring decisions and the reasons behind them in the readme file.

Challenge Requirements (Higher Grades):

1. **Implement a More Detailed Start Screen**
   - Enhance your start screen to offer more choices: Single player, Two-player (hot-seat), Change language, and Exit.
   - Use debugging tools to ensure that all menu options function as expected.

2. **Support Two-Player Hot-Seat Play**
   - Modify your game to support a two-player mode, where two players can play on the same machine, taking turns ("hot-seat").
   - Use debugging tools to ensure that this mode functions correctly.

3. **Implement a Splash Screen**
   - Add a splash screen that appears before the start screen.
   - Use debugging tools to make sure the splash screen displays and transitions correctly.

4. **Add ANSI Escape Codes to Add Color**
   - Enhance your game's user interface by using ANSI escape codes to add color.
   - Use debugging tools to make sure your color implementation works correctly.

5. **Propose and Implement a Custom Feature**
   - Come up with a custom feature that will enhance the game, then implement it. Submit a brief document explaining your feature, why you chose it, and any challenges you encountered while implementing it. 

Throughout this module, students should keep in mind that the ultimate goal is not only to build these features but also to learn from the process. They should aim to understand how different parts of a program interact, how to troubleshoot effectively, and how to write clean, effective code.

Evryone: In your README file, include a section where you highlight potential challenges or limitations in your code. Reflect on what could be done differently, and areas you believe could be improved.

All your code and related files should be neatly organized in a Zip file, with the following internal structure

    module_2_rps
    ├── RPS.cs
    ├── module_2_rps.csproj
    ├── module_2_rps.sln
    ├── readme.md
    └── *.*

**About assesment:**
-------------------

Assessment for this project will be based not just on feature completion, but also on your attention to detail, the cleanliness and readability of your code, and the thoughtfulness of your README file reflections. This is your opportunity to demonstrate not just what you've learned, but how you can apply it creatively and effectively in a real programming project.
